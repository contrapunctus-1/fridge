(declaim (optimize (speed 0) (safety 3) (debug 3)))

(in-package :fridge)

(defgeneric slots-used-as-link (class object slot)
  (:documentation "Returns the slots that are linking through the given slot."))
(defgeneric linked-slot-change (class object slot changed-slot new-value)
  (:documentation "This method is called for each slot before the slot's value is updated"))

(defgeneric complete-ring (object &rest objects)
  (:documentation "Loads all objects the given object is linked to and adds it to objects.  You are really only allowed to set the first object, the &rest is to force the fact that you have handled those objects yourself (and they will be returned too)."))
(defgeneric complete-ring-with-slot (object slot &rest objects)
  (:documentation "Loads all objects the given slot links to through the given object and adds it to objects."))
(defgeneric complete-stored-ring (object &rest objects)
  (:documentation "Completes an object ring, but never loads a new object, only searches through the quickstore"))
(defgeneric complete-stored-ring-with-slot (object slot &rest objects)
  (:documentation "Completes a list of objects through the slot of (class-of object), only through results it can find in the quickstore"))

(defclass linkable-column-direct-slot (column-direct-slot) ()
  (:documentation "Direct slot used for a column slot which may be used in a link (can be used for reverse links too)"))
(defclass linkable-column-effective-slot (direct-effective-slot) ()
  (:documentation "Effective slot used in combination with linkable-column-direct-slot"))

(defclass linkable-metaclass (quicksearch-support-metaclass)
  ()
  (:documentation "Allows for linked slots"))
(defmethod closer-mop:validate-superclass ((a linkable-metaclass) (b standard-class))
  T)
(defclass linkable-class (quicksearch-support-class)
  ((dependent-loaded-slot-names :accessor dependent-loaded-slot-names
				:documentation "This slot stores the names of the slots which have been pre-loaded.  A preloaded slot is certain that it can fetch all its slots through the quickstore"))
  (:metaclass linkable-metaclass)
  (:optimize-slot-access nil)
  (:documentation "Used in combination with linkable-metaclass"))

(defclass linked-direct-slot (standard-direct-slot-definition)
  ((external-class :accessor external-class)
   (internal-slot :accessor internal-slot))
  (:documentation "A linked direct slot has a link to an object, which is identified through its ID"))
(defclass linked-effective-slot (direct-effective-slot)
  ()
  (:documentation "see linked-direct-slot"))

(defclass linked-direct-slot-one (linked-direct-slot)
  ()
  (:documentation "A linked direct slot has a link to an object, which is identified through its ID"))
(defclass linked-effective-slot-one (direct-effective-slot)
  ()
  (:documentation "see linked-direct-slot"))

(defclass linked-direct-slot-many (linked-direct-slot)
  ()
  (:documentation "A linked direct slot has a link to an object, which is identified through its ID"))
(defclass linked-effective-slot-many (direct-effective-slot)
  ()
  (:documentation "see linked-direct-slot"))

(defclass master-direct-slot (linked-direct-slot-one)
  ()
  (:documentation "A slot which identifies this object's master"))
(defclass master-effective-slot (linked-effective-slot-one)
  ()
  (:documentation "see master-direct-slot"))

(defclass obediant-direct-slot (linked-direct-slot)
  ()
  (:documentation "linked slot which owns the linked object"))
(defclass obediant-effective-slot (linked-effective-slot)
  ()
  (:documentation "see obediant-direct-slot"))

(defclass obediant-direct-slot-one (obediant-direct-slot linked-direct-slot-one)
  ()
  (:documentation "A link to one owned object"))
(defclass obediant-effective-slot-one (obediant-effective-slot linked-effective-slot-one)
  ()
  (:documentation "see obediant-direct-slot-one"))

(defclass obediant-direct-slot-many (obediant-direct-slot linked-direct-slot-many)
  ()
  (:documentation "A link to -possbly many- owned objects"))
(defclass obediant-effective-slot-many (obediant-effective-slot linked-effective-slot-many)
  ()
  (:documentation "see obediant-direct-slot-many"))

(defmethod slot-depends-on-internal-slot-names (class slot)
  (declare (ignore class slot))
  nil)
(defmethod slot-depends-on-internal-slot-names :around ((class linkable-metaclass) (slot master-direct-slot))
  (cons (internal-slot slot) (call-next-method)))
(defmethod slot-depends-on-internal-slot-names :around ((class linkable-metaclass) (slot linkable-column-direct-slot))
  (cons (slot-name slot) (call-next-method)))

(defmethod slot-names-used-as-link ((class linkable-metaclass))
  (remove-duplicates 
   (loop for slot in (class-direct-slots class)
      append (slot-depends-on-internal-slot-names class slot))))

(defmethod (setf slot-value-using-class) :before (value (class linkable-metaclass) (object linkable-class) (slot direct-effective-slot))
  (let ((slot (direct-slot slot)))
    (when (find (slot-name slot) (slot-names-used-as-link class))
      (when (slot-boundp object (slot-name slot))
	(quickrm object (slot-name slot) (slot-value object (slot-name slot))))
      (quickstore object (slot-name slot) value))))

(defmethod quickstore-again :after ((object linkable-class))
  (dolist (slot-name (slot-names-used-as-link (class-of object)))
    (when (slot-boundp object slot-name)
      (quickstore object slot-name)))
  object)

(defmethod delete-instance :after ((object linkable-class))
  (dolist (slot-name (slot-names-used-as-link (class-of object)))
    (when (slot-boundp object slot-name)
      (quickrm object slot-name))))

(define-condition object-missing-id (warning)
  ((comment :initarg :comment))
  (:documentation "Signaled when the id of an object could not be found"))

(defmethod shared-initialize :after ((lds linked-direct-slot) slot-names &rest args &key external-class slot &allow-other-keys)
  (declare (ignore slot-names args))
  (setf (external-class lds) external-class)
  (setf (internal-slot lds) slot))

(defmethod direct-slot-definition-class :around ((class linkable-metaclass) &key linkable-p external-class slot (i-am-master-p nil master-p) (i-am-obediant-p nil obediant-p) amount &allow-other-keys)
  (declare (ignore class))
  (when (or (and master-p obediant-p
		 (or (and (not i-am-master-p) (not i-am-obediant-p))
		     (and i-am-master-p i-am-obediant-p))))
    (error "Can't be and master and obediant"))
  (when (and (or i-am-master-p (and obediant-p (not i-am-obediant-p)))
	     (not amount))
    (error "Must specify amount when you are master"))
  (when (and (or external-class slot i-am-master-p i-am-obediant-p amount)
	     linkable-p)
    (error "Can't be a linkable class when you're referring to another object"))
  (if linkable-p
      (find-class 'linkable-column-direct-slot)
      (if (and (not i-am-master-p)
	       (not i-am-obediant-p))
	  (call-next-method)
	  (if (or i-am-master-p (and obediant-p (not i-am-obediant-p)))
	      (if (or (eql amount :one)
		      (eql amount :1)
		      (equal amount 1))
		  (find-class 'obediant-direct-slot-one)
		  (find-class 'obediant-direct-slot-many))
	      (find-class 'master-direct-slot)))))

(defmethod effective-slot-definition-class :around ((class linkable-metaclass) &rest args)
  (declare (ignore args))
  (cond ((find (find-class 'master-direct-slot) *direct-slots* :key #'class-of)
	 (find-class 'master-effective-slot))
	((find (find-class 'obediant-direct-slot-one) *direct-slots* :key #'class-of)
	 (find-class 'obediant-effective-slot-one))
	((find (find-class 'obediant-direct-slot-many) *direct-slots* :key #'class-of)
	 (find-class 'obediant-effective-slot-many))
	((find (find-class 'linkable-column-direct-slot) *direct-slots* :key #'class-of)
	 (find-class 'linkable-column-effective-slot))
	(T
	 (call-next-method))))

(defmethod (setf slot-value-using-class) (value (class linkable-metaclass) (object linkable-class) (slot obediant-effective-slot))
  (let ((id-slot-name (id-slot-name object)))
    (unless (and (slot-boundp object id-slot-name)
		 (slot-value object id-slot-name)
		 (not (eql (slot-value object id-slot-name) :null)))
      (warn 'object-missing-id :comment "Can't assign to an object that doesn't have an id"))))
(defmethod (setf slot-value-using-class) :around (value (class linkable-metaclass) object (slot obediant-effective-slot-many))
  (let ((slot (direct-slot slot)))
    (let ((current-values (slot-value object (slot-name slot))))
      (when (object-in-database-p object)
	(dolist (i-object current-values)
	  (unless (find i-object value)
	    (quickrm i-object (internal-slot slot))
	    (slot-makunbound i-object (internal-slot slot))
	    (delete-instance i-object))))
      (call-next-method)
      (dolist (x value)
	(unless (find x current-values)
	  (setf (slot-value x (internal-slot slot)) (id object)))))))
(defmethod (setf slot-value-using-class) :after (new-object (class linkable-metaclass) object (slot obediant-effective-slot-one))
  (let ((slot (direct-slot slot)))
    (let ((current-object (slot-value object (slot-name slot))))
      (quickrm current-object (internal-slot slot))
      (slot-makunbound current-object (internal-slot slot))
      (delete-instance current-object))
    (setf (slot-value new-object (internal-slot slot)) (id object))))
(defmethod (setf slot-value-using-class) (value (class linkable-metaclass) object (slot master-effective-slot))
  (unless (eql value :null)
    (if (id value)
	(let ((slot (direct-slot slot))) (setf (slot-value object (internal-slot slot)) (id value)))
	(warn 'object-missing-id :comment "Can't assign an unsaved object"))))

(defmethod slot-value-using-class ((class linkable-metaclass) object (slot obediant-effective-slot-one))
  (let ((slot (direct-slot slot)))
    (handler-case
	(load-instance-from-slot (external-class slot) (internal-slot slot) (id object))
      (record-not-found-error () nil))))
(defmethod slot-value-using-class :around ((class linkable-metaclass) object (slot obediant-effective-slot-many))
  (let ((slot (direct-slot slot)))
    (if (handler-case (find (slot-name slot) (slot-value object 'dependent-loaded-slot-names))
	  (unbound-slot () (setf (slot-value object 'dependent-loaded-slot-names) nil)))
	(quickfetch-all (build-hash-identifier (external-class slot) (internal-slot slot) (id object)))
	(load-instances-from-slot (external-class slot) (internal-slot slot) (id object)))))
(defmethod slot-value-using-class ((class linkable-metaclass) object (slot master-effective-slot))
  (let ((slot (direct-slot slot)))
    (when (slot-boundp object (internal-slot slot))
      (load-instance-from-slot (external-class slot) (id-slot-name (external-class slot)) (slot-value object (internal-slot slot))))))

;; object-ring


(defmethod complete-ring (object &rest objects)
  (declare (ignore object))
  objects)
(defmethod complete-ring ((object linkable-class) &rest objects)
  (if (find object objects)
      objects
      (let ((objectss (cons object objects)))
	(loop for slot in (class-direct-slots (class-of object))
	   do (setf objectss (apply #'complete-ring-with-slot object slot objectss)))
	objectss)))

(defmethod complete-ring-with-slot (object slot &rest objects)
  (declare (ignore object slot))
  objects)
(defmethod complete-ring-with-slot ((object linkable-class) (slot linked-direct-slot-one) &rest objects)
  (let ((value (slot-value object (slot-name slot))))
    (if value
	(apply #'complete-ring value objects)
	objects)))
(defmethod complete-ring-with-slot ((object linkable-class) (slot linked-direct-slot-many) &rest objects)
  (let ((values (slot-value object (slot-name slot))))
    (loop for value in values
       do (setf objects (apply #'complete-ring value objects))))
  objects)

(defmethod complete-stored-ring (object &rest objects)
  (declare (ignore object))
  objects)
(defmethod complete-stored-ring ((object linkable-class) &rest objects)
  (if (find object objects)
      objects
      (let ((objectss (cons object objects)))
	(loop for slot in (class-direct-slots (class-of object))
	   do (setf objectss (apply #'complete-stored-ring-with-slot object slot objectss)))
	objectss)))

(defmethod complete-stored-ring-with-slot (object slot &rest objects)
  (declare (ignore object slot))
  objects)
(defmethod complete-stored-ring-with-slot ((object linkable-class) (slot master-direct-slot) &rest objects)
  (let ((value (quickfetch (build-hash-id (external-class slot) (slot-value object (internal-slot slot))))))
    (if value
	(apply #'complete-stored-ring value objects)
	objects)))
(defmethod complete-stored-ring-with-slot ((object linkable-class) (slot obediant-direct-slot) &rest objects)
  (let ((values (quickfetch-all (build-hash-identifier (external-class slot) (internal-slot slot) (id object)))))
    (loop for value in values
       do (setf objects (apply #'complete-stored-ring value objects)))
    objects))
